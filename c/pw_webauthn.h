/**
 * The file perform TRON wallet signature verification.
 *
 * The TRON wallet signature is generated by window.tronWeb.trx.sign().
 * tronWeb API is refer to
 * https://developers.tron.network/docs/tronlink-integration#signature
 *
 */

#include "common.h"
#include "protocol.h"
#include "pw_r1_helper.h"

#define R1_WITNESS_LOCK_SIZE 564
#define R1_SIGNATURE_SIZE 64
#define AUTHR_DATA_SIZE 37

/**
 * check the challenge of client data json is equal to tx message digest
 * @param digest_message transation digest message
 * @param client_data the client data represents the contextual bindings of both
 * the WebAuthn Relying Party and the client
 * @param client_data_len the length of client data
 *
 */
int verify_challenge_in_client_data(const u8* digest_message,
                                    const u8* client_data, u8 client_data_len) {
  u8 challenge_b64[44];
  u8 challenge_decode[33];
  size_t challenge_decode_len = 33;

  /*  ASCII code for string \"challenge\":\"  */
  u8 prefix[] = {34, 99, 104, 97, 108, 108, 101, 110, 103, 101, 34, 58, 34};
  int prefix_len = 13;

  /* ASCII code for \" */
  u8 suffix[] = {34};
  int suffix_len = 1;

  int challenge_b64_start = 0;
  int challenge_b64_len = 0;

  /* extract challenge value from client data*/
  int i = 0;
  while (i < client_data_len - prefix_len) {
    if (memcmp(client_data + i, prefix, prefix_len) == 0) {
      int j = i + prefix_len;

      while (j < client_data_len) {
        if (memcmp(client_data + j, suffix, suffix_len) == 0) {
          challenge_b64_len = j - i - prefix_len;
          break;
        }
        j++;
      }

      challenge_b64_start = i + prefix_len;
      if (challenge_b64_len > 0) {
        break;
      }
    }
    i++;
  }

  if (challenge_b64_len <= 0) {
    return -1;
  }

  memcpy(challenge_b64, client_data + challenge_b64_start, challenge_b64_len);

  while (challenge_b64_len < 44) {
    challenge_b64[challenge_b64_len] = '=';
    challenge_b64_len++;
  }

  urlsafe_b64_decode((const char*)challenge_b64, 44, challenge_decode,
                     &challenge_decode_len);

  /* compare the challenge of client data with the tx message digest */
  if (challenge_decode_len == 32 &&
      memcmp(challenge_decode, digest_message, 32) == 0) {
    return 0;
  }

  return ERROR_WRONG_CHALLENGE;
}

/**
 * @param message: transaction message digest, size is 32 bytes
 * @param lock_args: last 20 bytes sha256 hash of pubkey, used to shield
 * the real pubkey. size is 20 bytes
 * @param lock_bytes: transaction signature in witness.lock, size is 500 bytes
 *
 */
int validate_webauthn(unsigned char* message, unsigned char* lock_args,
                      unsigned char* lock_bytes, uint64_t lock_bytes_size) {
  if (lock_bytes_size != R1_WITNESS_LOCK_SIZE) {
    return ERROR_WITNESS_SIZE;
  }

  unsigned char pub_key[R1_PUBKEY_SIZE];

  /* check pubkey's hash equal to lock script args */
  unsigned char pub_key_hash[HASH_SIZE];
  memcpy(pub_key, lock_bytes, R1_PUBKEY_SIZE);
  sha256(pub_key, R1_PUBKEY_SIZE, pub_key_hash);

  if (memcmp(lock_args, pub_key_hash, LOCK_ARGS_SIZE) != 0) {
    return ERROR_WRONG_SIGNATURE;
  }

  int i = 0;
  for (i = R1_WITNESS_LOCK_SIZE - 1; i >= 0; i--) {
    if (lock_bytes[i] != 0) {
      break;
    }
  }
  int client_data_size =
      i - R1_PUBKEY_SIZE - R1_SIGNATURE_SIZE - AUTHR_DATA_SIZE + 1;

  /* verify challenge in client_data */
  int ret = verify_challenge_in_client_data(
      message,
      lock_bytes + R1_PUBKEY_SIZE + R1_SIGNATURE_SIZE + AUTHR_DATA_SIZE,
      client_data_size);
  if (ret != CKB_SUCCESS) {
    return ret;
  }

  /* build message_to_sign */
  u8 client_data_hash[HASH_SIZE];
  u8 message_to_sign[AUTHR_DATA_SIZE + HASH_SIZE];
  sha256(lock_bytes + R1_PUBKEY_SIZE + R1_SIGNATURE_SIZE + AUTHR_DATA_SIZE,
         client_data_size, client_data_hash);

  memcpy(message_to_sign, lock_bytes + R1_PUBKEY_SIZE + R1_SIGNATURE_SIZE,
         AUTHR_DATA_SIZE);
  memcpy(message_to_sign + AUTHR_DATA_SIZE, client_data_hash, HASH_SIZE);

  return verify_secp256r1_signature(pub_key, (const u8*)message_to_sign,
                                    lock_bytes + R1_PUBKEY_SIZE);
}
